# Простейший интерфейс для работы с ollama 


import sys
import json
import time
import pprint
import platform
import webbrowser
import urllib.parse
import urllib.request
from threading import Thread
from typing import Optional, List, Generator

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QPushButton, QComboBox, QLineEdit, QTextEdit, QProgressBar, QLabel,
    QListWidget, QFrame, QScrollArea, QMenuBar, QMenu, QMessageBox,
    QSplitter, QSizePolicy
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QEvent
from PyQt6.QtGui import QFont, QAction, QCursor, QTextCursor, QClipboard

version = "1.2.1"


def _system_check() -> Optional[str]:
    """
    Detected some system and software compatibility issues,
    and returned the information in the form of a string to alert the user
    """

    def _version_tuple(v):
        """A lazy way to avoid importing third-party libraries"""
        filled = []
        for point in v.split("."):
            filled.append(point.zfill(8))
        return tuple(filled)

    # Tcl and macOS issue: https://github.com/python/cpython/issues/110218
    if platform.system().lower() == "darwin":
        version = platform.mac_ver()[0]
        if version and 14 <= float(version) < 15:
            return (
                "Warning: Potential GUI Responsiveness Issue\n\n"
                "You may experience GUI performance issues on macOS Sonoma. "
                "This is a known issue with some GUI frameworks on this OS version.\n\n"
                "For more information, visit: https://github.com/python/cpython/issues/110218"
            )
    return None


class ModelWorker(QThread):
    """Worker thread for model operations"""
    finished = pyqtSignal()
    error = pyqtSignal(str)
    models_fetched = pyqtSignal(list)
    log_message = pyqtSignal(str)

    def __init__(self, api_url: str, operation: str = "fetch", model_name: str = ""):
        super().__init__()
        self.api_url = api_url
        self.operation = operation
        self.model_name = model_name

    def run(self):
        try:
            if self.operation == "fetch":
                models = self.fetch_models()
                self.models_fetched.emit(models)
            elif self.operation == "download":
                self.download_model(self.model_name)
            elif self.operation == "delete":
                self.delete_model(self.model_name)
        except Exception as e:
            self.error.emit(str(e))
        finally:
            self.finished.emit()

    def fetch_models(self) -> List[str]:
        with urllib.request.urlopen(
                urllib.parse.urljoin(self.api_url, "/api/tags")
        ) as response:
            data = json.load(response)
            models = [model["name"] for model in data["models"]]
            return models

    def download_model(self, model_name: str, insecure: bool = False):
        self.log_message.emit("Starting download...")
        if not model_name:
            return

        req = urllib.request.Request(
            urllib.parse.urljoin(self.api_url, "/api/pull"),
            data=json.dumps(
                {"name": model_name, "insecure": insecure, "stream": True}
            ).encode("utf-8"),
            method="POST",
        )

        with urllib.request.urlopen(req) as response:
            for line in response:
                data = json.loads(line.decode("utf-8"))
                log = data.get("error") or data.get("status") or "No response"
                if "status" in data:
                    total = data.get("total")
                    completed = data.get("completed", 0)
                    if total:
                        log += f" [{completed}/{total}]"
                self.log_message.emit(log)

    def delete_model(self, model_name: str):
        if not model_name:
            return

        req = urllib.request.Request(
            urllib.parse.urljoin(self.api_url, "/api/delete"),
            data=json.dumps({"name": model_name}).encode("utf-8"),
            method="DELETE",
        )

        with urllib.request.urlopen(req) as response:
            if response.status == 200:
                self.log_message.emit("Model deleted successfully.")
            elif response.status == 404:
                self.log_message.emit("Model not found.")


class ChatWorker(QThread):
    """Worker thread for chat responses"""
    response_chunk = pyqtSignal(str)
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    def __init__(self, api_url: str, model: str, chat_history: List[dict]):
        super().__init__()
        self.api_url = api_url
        self.model = model
        self.chat_history = chat_history
        self.should_stop = False

    def run(self):
        try:
            ai_message = ""
            for chunk in self.fetch_chat_stream_result():
                if self.should_stop:
                    break
                self.response_chunk.emit(chunk)
                ai_message += chunk
            self.finished.emit(ai_message)
        except Exception as e:
            self.error.emit(str(e))

    def stop(self):
        self.should_stop = True

    def fetch_chat_stream_result(self) -> Generator:
        request = urllib.request.Request(
            urllib.parse.urljoin(self.api_url, "/api/chat"),
            data=json.dumps(
                {
                    "model": self.model,
                    "messages": self.chat_history,
                    "stream": True,
                }
            ).encode("utf-8"),
            headers={"Content-Type": "application/json"},
            method="POST",
        )

        with urllib.request.urlopen(request) as resp:
            for line in resp:
                if self.should_stop:
                    break
                data = json.loads(line.decode("utf-8"))
                if "message" in data:
                    time.sleep(0.01)
                    yield data["message"]["content"]


class ChatBubble(QLabel):
    """Custom chat bubble widget"""

    def __init__(self, text: str, is_user: bool = False, parent=None):
        super().__init__(parent)
        self.setText(text)
        self.setWordWrap(True)
        self.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
        self.setContentsMargins(8, 8, 8, 8)

        if is_user:
            self.setStyleSheet("""
                QLabel {
                    background-color: #48a4f2;
                    color: white;
                    border-radius: 10px;
                    padding: 8px;
                }
            """)
            self.setAlignment(Qt.AlignmentFlag.AlignRight)
        else:
            self.setStyleSheet("""
                QLabel {
                    background-color: #eaeaea;
                    color: black;
                    border-radius: 10px;
                    padding: 8px;
                }
            """)
            self.setAlignment(Qt.AlignmentFlag.AlignLeft)

        self.setMaximumWidth(400)
        self.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum)


class ModelManagementWindow(QWidget):
    """Model management window"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent_interface = parent
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle("Model Management")
        self.setGeometry(400, 300, 400, 500)

        layout = QVBoxLayout()

        # Download section
        download_frame = QFrame()
        download_layout = QHBoxLayout(download_frame)

        self.model_name_input = QLineEdit()
        self.model_name_input.setPlaceholderText("Enter model name (e.g., llama2)")
        download_layout.addWidget(self.model_name_input)

        self.download_button = QPushButton("Download")
        self.download_button.clicked.connect(self.download_model)
        download_layout.addWidget(self.download_button)

        layout.addWidget(download_frame)

        # Tips label
        tips_label = QLabel('<a href="https://ollama.com/library">find models: https://ollama.com/library</a>')
        tips_label.setOpenExternalLinks(True)
        layout.addWidget(tips_label)

        # Models list
        list_frame = QFrame()
        list_layout = QHBoxLayout(list_frame)

        self.models_list = QListWidget()
        list_layout.addWidget(self.models_list)

        self.delete_button = QPushButton("Delete")
        self.delete_button.clicked.connect(self.delete_model)
        list_layout.addWidget(self.delete_button)

        layout.addWidget(list_frame)

        # Log textbox
        self.log_textbox = QTextEdit()
        self.log_textbox.setReadOnly(True)
        layout.addWidget(self.log_textbox)

        self.setLayout(layout)

    def download_model(self):
        model_name = self.model_name_input.text().strip()
        if model_name.startswith("ollama run "):
            model_name = model_name[11:]

        if model_name and self.parent_interface:
            self.log_textbox.clear()
            self.download_button.setEnabled(False)
            self.parent_interface.download_model_async(model_name)

    def delete_model(self):
        current_item = self.models_list.currentItem()
        if current_item and self.parent_interface:
            model_name = current_item.text().strip()
            self.log_textbox.clear()
            self.parent_interface.delete_model_async(model_name)

    def update_models_list(self, models: List[str]):
        self.models_list.clear()
        for model in models:
            self.models_list.addItem(model)

    def append_log(self, message: str):
        self.log_textbox.append(message)

    def enable_download_button(self):
        self.download_button.setEnabled(True)


class OllamaInterface(QMainWindow):
    def __init__(self):
        super().__init__()
        self.api_url = "http://127.0.0.1:11434"
        self.chat_history = []
        self.chat_worker = None
        self.model_worker = None
        self.management_window = None
        self.current_response_bubble = None

        self.init_ui()
        self.check_system()

        # Refresh models after UI initialization
        QTimer.singleShot(200, self.refresh_models)

    def init_ui(self):
        self.setWindowTitle("Ollama GUI")
        self.setGeometry(100, 100, 800, 600)

        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main layout
        main_layout = QVBoxLayout(central_widget)

        # Header
        self.create_header(main_layout)

        # Progress bar (initially hidden)
        self.create_progress_bar(main_layout)

        # Chat area
        self.create_chat_area(main_layout)

        # Input area
        self.create_input_area(main_layout)

        # Menu bar
        self.create_menu_bar()

    def create_header(self, main_layout):
        header_frame = QFrame()
        header_layout = QHBoxLayout(header_frame)

        self.model_select = QComboBox()
        self.model_select.setMinimumWidth(200)
        header_layout.addWidget(self.model_select)

        settings_button = QPushButton("⚙️")
        settings_button.setMaximumWidth(30)
        settings_button.clicked.connect(self.show_model_management)
        header_layout.addWidget(settings_button)

        self.refresh_button = QPushButton("Refresh")
        self.refresh_button.clicked.connect(self.refresh_models)
        header_layout.addWidget(self.refresh_button)

        header_layout.addStretch()

        header_layout.addWidget(QLabel("Host:"))

        self.host_input = QLineEdit()
        self.host_input.setText(self.api_url)
        self.host_input.setMinimumWidth(200)
        header_layout.addWidget(self.host_input)

        main_layout.addWidget(header_frame)

    def create_progress_bar(self, main_layout):
        progress_frame = QFrame()
        progress_layout = QHBoxLayout(progress_frame)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 0)  # Indeterminate progress
        progress_layout.addWidget(self.progress_bar)

        self.stop_button = QPushButton("Stop")
        self.stop_button.clicked.connect(self.stop_generation)
        progress_layout.addWidget(self.stop_button)

        main_layout.addWidget(progress_frame)

        # Initially hidden
        progress_frame.hide()
        self.progress_frame = progress_frame

    def create_chat_area(self, main_layout):
        # Create scroll area for chat
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # ИСПРАВЛЕНО

        # Chat container
        self.chat_container = QWidget()
        self.chat_layout = QVBoxLayout(self.chat_container)
        self.chat_layout.addStretch()  # Push messages to bottom initially

        scroll_area.setWidget(self.chat_container)
        main_layout.addWidget(scroll_area)

        self.scroll_area = scroll_area

        # Context menu for chat area
        self.chat_container.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.chat_container.customContextMenuRequested.connect(self.show_chat_context_menu)

    def create_input_area(self, main_layout):
        input_frame = QFrame()
        input_layout = QHBoxLayout(input_frame)

        self.user_input = QTextEdit()
        self.user_input.setMaximumHeight(100)
        self.user_input.setPlaceholderText("Type your message here... (Enter to send, Shift+Enter for new line)")
        input_layout.addWidget(self.user_input)

        self.send_button = QPushButton("Send")
        self.send_button.setEnabled(False)
        self.send_button.clicked.connect(self.send_message)
        input_layout.addWidget(self.send_button)

        main_layout.addWidget(input_frame)

        # Handle Enter key
        self.user_input.installEventFilter(self)

    def create_menu_bar(self):
        menubar = self.menuBar()

        # File menu
        file_menu = menubar.addMenu("File")

        model_mgmt_action = QAction("Model Management", self)
        model_mgmt_action.triggered.connect(self.show_model_management)
        file_menu.addAction(model_mgmt_action)

        file_menu.addSeparator()

        exit_action = QAction("Exit", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Edit menu
        edit_menu = menubar.addMenu("Edit")

        copy_all_action = QAction("Copy All", self)
        copy_all_action.triggered.connect(self.copy_all)
        edit_menu.addAction(copy_all_action)

        clear_chat_action = QAction("Clear Chat", self)
        clear_chat_action.triggered.connect(self.clear_chat)
        edit_menu.addAction(clear_chat_action)

        # Help menu
        help_menu = menubar.addMenu("Help")

        source_action = QAction("Source Code", self)
        source_action.triggered.connect(self.open_homepage)
        help_menu.addAction(source_action)

        help_action = QAction("Help", self)
        help_action.triggered.connect(self.show_help)
        help_menu.addAction(help_action)

    def eventFilter(self, obj, event):
        if obj == self.user_input and event.type() == QEvent.Type.KeyPress:
            if event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
                if event.modifiers() & Qt.KeyboardModifier.ShiftModifier:
                    # Shift+Enter: new line
                    return False
                else:
                    # Enter: send message
                    if self.send_button.isEnabled():
                        self.send_message()
                    return True
        return super().eventFilter(obj, event)

    def check_system(self):
        message = _system_check()
        if message:
            QMessageBox.warning(self, "Warning", message)

    def refresh_models(self):
        self.api_url = self.host_input.text()
        self.model_select.setStyleSheet("")
        self.model_select.clear()
        self.model_select.addItem("Waiting...")
        self.send_button.setEnabled(False)
        self.refresh_button.setEnabled(False)

        self.model_worker = ModelWorker(self.api_url, "fetch")
        self.model_worker.models_fetched.connect(self.on_models_fetched)
        self.model_worker.error.connect(self.on_models_error)
        self.model_worker.finished.connect(self.on_models_finished)
        self.model_worker.start()

    def on_models_fetched(self, models):
        self.model_select.clear()
        if models:
            self.model_select.addItems(models)
            self.send_button.setEnabled(True)
        else:
            self.model_select.addItem("You need to download a model!")
            self.model_select.setStyleSheet("color: red;")

    def on_models_error(self, error):
        self.model_select.clear()
        self.model_select.addItem("Error! Please check the host.")
        self.model_select.setStyleSheet("color: red;")

    def on_models_finished(self):
        self.refresh_button.setEnabled(True)
        if self.management_window:
            self.management_window.update_models_list([
                self.model_select.itemText(i) for i in range(self.model_select.count())
            ])

    def send_message(self):
        message = self.user_input.toPlainText().strip()
        if not message:
            return

        # Add user message
        self.add_chat_bubble(message, is_user=True)
        self.chat_history.append({"role": "user", "content": message})

        # Clear input
        self.user_input.clear()

        # Start AI response
        self.start_ai_response()

    def add_chat_bubble(self, text: str, is_user: bool = False):
        bubble = ChatBubble(text, is_user)

        # Create container for alignment
        container = QWidget()
        container_layout = QHBoxLayout(container)
        container_layout.setContentsMargins(10, 5, 10, 5)

        if is_user:
            container_layout.addStretch()
            container_layout.addWidget(bubble)
        else:
            container_layout.addWidget(bubble)
            container_layout.addStretch()

        # Remove the stretch at the end if it exists
        if self.chat_layout.count() > 0:
            last_item = self.chat_layout.itemAt(self.chat_layout.count() - 1)
            if last_item.spacerItem():
                self.chat_layout.removeItem(last_item)

        self.chat_layout.addWidget(container)
        self.chat_layout.addStretch()

        # Scroll to bottom
        QTimer.singleShot(10, self.scroll_to_bottom)

        return bubble

    def scroll_to_bottom(self):
        scrollbar = self.scroll_area.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def start_ai_response(self):
        self.progress_frame.show()
        self.send_button.setEnabled(False)
        self.refresh_button.setEnabled(False)

        # Add model name
        model_name = self.model_select.currentText()
        model_label = QLabel(f"<b>{model_name}</b>")
        model_label.setStyleSheet("color: #ff007b; margin: 5px 10px;")
        self.chat_layout.insertWidget(self.chat_layout.count() - 1, model_label)

        # Create empty bubble for AI response
        self.current_response_bubble = self.add_chat_bubble("", is_user=False)

        # Start chat worker
        self.chat_worker = ChatWorker(self.api_url, model_name, self.chat_history.copy())
        self.chat_worker.response_chunk.connect(self.on_response_chunk)
        self.chat_worker.finished.connect(self.on_response_finished)
        self.chat_worker.error.connect(self.on_response_error)
        self.chat_worker.start()

    def on_response_chunk(self, chunk: str):
        if self.current_response_bubble:
            current_text = self.current_response_bubble.text()
            self.current_response_bubble.setText(current_text + chunk)
            self.scroll_to_bottom()

    def on_response_finished(self, full_response: str):
        self.chat_history.append({"role": "assistant", "content": full_response})
        self.current_response_bubble = None

        self.progress_frame.hide()
        self.send_button.setEnabled(True)
        self.refresh_button.setEnabled(True)

    def on_response_error(self, error: str):
        if self.current_response_bubble:
            self.current_response_bubble.setText(f"AI error: {error}")
            self.current_response_bubble.setStyleSheet("""
                QLabel {
                    background-color: #ffebee;
                    color: red;
                    border-radius: 10px;
                    padding: 8px;
                }
            """)

        self.progress_frame.hide()
        self.send_button.setEnabled(True)
        self.refresh_button.setEnabled(True)

    def stop_generation(self):
        if self.chat_worker:
            self.chat_worker.stop()
            self.chat_worker.wait()

    def show_model_management(self):
        if self.management_window is None:
            self.management_window = ModelManagementWindow(self)

        self.management_window.show()
        self.management_window.raise_()
        self.management_window.activateWindow()

        # Update models list
        models = [self.model_select.itemText(i) for i in range(self.model_select.count())]
        self.management_window.update_models_list(models)

    def download_model_async(self, model_name: str):
        worker = ModelWorker(self.api_url, "download", model_name)
        worker.log_message.connect(self.management_window.append_log)
        worker.finished.connect(self.on_model_operation_finished)
        worker.start()

    def delete_model_async(self, model_name: str):
        worker = ModelWorker(self.api_url, "delete", model_name)
        worker.log_message.connect(self.management_window.append_log)
        worker.finished.connect(self.on_model_operation_finished)
        worker.start()

    def on_model_operation_finished(self):
        if self.management_window:
            self.management_window.enable_download_button()
        self.refresh_models()

    def show_chat_context_menu(self, position):
        context_menu = QMenu(self)

        copy_all_action = context_menu.addAction("Copy All")
        copy_all_action.triggered.connect(self.copy_all)

        context_menu.addSeparator()

        clear_chat_action = context_menu.addAction("Clear Chat")
        clear_chat_action.triggered.connect(self.clear_chat)

        context_menu.exec(self.chat_container.mapToGlobal(position))

    def copy_all(self):
        clipboard = QApplication.clipboard()
        clipboard.setText(pprint.pformat(self.chat_history))

    def clear_chat(self):
        # Clear layout
        while self.chat_layout.count() > 1:  # Keep the stretch
            child = self.chat_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        # Clear history
        self.chat_history.clear()

        # Add stretch back
        self.chat_layout.addStretch()

    @staticmethod
    def open_homepage():
        webbrowser.open("")

    def show_help(self):
        info = (f"Project: Ollama GUI\n"
                f"Version: {version}\n"
                f"Author: xyi\n"
                f"Github: \n\n"
                f"<Enter>: send\n"
                f"<Shift+Enter>: new line\n"
                f"<Right click>: context menu")
        QMessageBox.about(self, "About", info)


def run():
    app = QApplication(sys.argv)
    app.setApplicationName("Ollama GUI")
    app.setApplicationVersion(version)

    # Set application style
    app.setStyle('Fusion')

    interface = OllamaInterface()
    interface.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    run()
